package com.verizon.upgrade.service;

import com.verizon.upgrade.dto.VulnerabilityResponse;
import com.verizon.upgrade.model.SoftwareArtifact;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@Slf4j
public class VulnerabilityService {

    @Autowired
    private ArtifactService artifactService;

    public List<VulnerabilityResponse> parseVulnerabilityExcel(MultipartFile file) throws Exception {
        // Use a Set to automatically remove duplicate rows
        Set<VulnerabilityResponse> uniqueResults = new LinkedHashSet<>();

        try (Workbook workbook = WorkbookFactory.create(file.getInputStream())) {
            Sheet sheet = workbook.getSheetAt(0);

            // --- STEP 1: Attempt to find headers dynamically ---
            int ipIdx = -1, hostIdx = -1, familyIdx = -1, vulIdx = -1, outputIdx = -1;
            boolean headersFound = false;
            int headerRowNum = -1;

            log.info("Starting Header Search (Full File)...");
            Iterator<Row> searchIterator = sheet.iterator();
            while (searchIterator.hasNext()) {
                Row row = searchIterator.next();

                // LIMIT REMOVED: We now scan every row until headers are found or EOF

                for (Cell cell : row) {
                    String h = getCellValue(cell).toLowerCase().trim();
                    if (ipIdx == -1 && (h.contains("ip address") || h.equals("ip")))
                        ipIdx = cell.getColumnIndex();
                    else if (hostIdx == -1 && (h.contains("hostname") || h.contains("dns name")
                            || h.contains("system name") || h.contains("asset name")))
                        hostIdx = cell.getColumnIndex();
                    else if (familyIdx == -1 && (h.contains("family") || h.contains("plugin family")))
                        familyIdx = cell.getColumnIndex();
                    else if (vulIdx == -1 && (h.contains("vul name") || h.contains("plugin name") || h.equals("name")))
                        vulIdx = cell.getColumnIndex();
                    else if (outputIdx == -1 && (h.contains("plugin output") || h.contains("output")))
                        outputIdx = cell.getColumnIndex();
                }

                // If we found the critical columns, lock them in
                if (ipIdx != -1 && hostIdx != -1) {
                    headersFound = true;
                    headerRowNum = row.getRowNum();
                    // Set defaults for others if specific headers weren't matched
                    if (familyIdx == -1)
                        familyIdx = 36;
                    if (vulIdx == -1)
                        vulIdx = 35;
                    if (outputIdx == -1)
                        outputIdx = 46;
                    log.info("Headers FOUND on Row {}: IP={} Host={} Family={} Vul={} Output={}", headerRowNum, ipIdx,
                            hostIdx, familyIdx, vulIdx, outputIdx);
                    break;
                }
                // Reset for next row
                ipIdx = -1;
                hostIdx = -1;
                familyIdx = -1;
                vulIdx = -1;
                outputIdx = -1;
            }

            // --- STEP 2: Fallback if headers missing ---
            if (!headersFound) {
                log.warn("Headers NOT found by name after scanning full file. Falling back to OBSERVED LOG INDICES.");
                // CORRECTED INDICES BASED ON YOUR LOGS
                ipIdx = 0;
                hostIdx = 1;
                vulIdx = 35;
                familyIdx = 36;
                outputIdx = 46;
            }

            // --- STEP 3: Process Data ---
            Iterator<Row> dataIterator = sheet.iterator();
            while (dataIterator.hasNext()) {
                Row row = dataIterator.next();

                // Skip header row and empty rows
                if (row.getRowNum() == headerRowNum || row == null || row.getLastCellNum() <= 0)
                    continue;

                // Skip if this looks like a header repetition
                String checkIp = getCellValue(row.getCell(ipIdx));
                if (checkIp.toLowerCase().contains("ip address") || checkIp.toLowerCase().equals("ip"))
                    continue;

                Cell familyCell = row.getCell(familyIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                Cell outputCell = row.getCell(outputIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);

                String family = getCellValue(familyCell);
                String pluginOutput = getCellValue(outputCell);

                // 1. General Exclusion Filter
                if (containsAny(family, "Local security checks", "Kernal.", "General",
                        "Oracle Linux Local Security Checks")) {
                    continue;
                }

                String path = extractPath(pluginOutput);
                if (path.isEmpty())
                    continue; // Skip if no path found

                // 2. STRICT PATH FILTERING: Only /apps/opt/application/mw or /apps/opt/mw
                boolean isTargetMiddleware = startsWithAny(path, "/apps/opt/application/mw", "/apps/opt/mw");

                if (isTargetMiddleware) {
                    String softwareType = deriveSoftware(path);
                    String targetVersionValue = extractFix(pluginOutput);

                    List<String> availableVersions = artifactService.getByType(softwareType)
                            .stream()
                            .map(SoftwareArtifact::getVersion)
                            .sorted(Comparator.reverseOrder())
                            .collect(Collectors.toList());

                    String nearestVersion = findNearestVersion(availableVersions, targetVersionValue);

                    VulnerabilityResponse responseRow = VulnerabilityResponse.builder()
                            .hostname(getCellValue(row.getCell(hostIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .ipAddress(getCellValue(row.getCell(ipIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .vulnerabilities(
                                    getCellValue(row.getCell(vulIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .directory(path)
                            .software(softwareType)
                            .currentVersion(extractVersion(pluginOutput))
                            .targetVersion(targetVersionValue)
                            .availableVersions(availableVersions)
                            .nearestVersion(nearestVersion)
                            .status(nearestVersion.isEmpty() ? "Not Prepared" : "Ready to Patch")
                            .action(nearestVersion.isEmpty() ? "Upload Software" : "Patch Now")
                            .build();

                    // Add to Set (automatically handles duplicates)
                    uniqueResults.add(responseRow);
                }
            }
        }

        log.info("Finished parsing. Found {} unique vulnerabilities.", uniqueResults.size());
        return new ArrayList<>(uniqueResults);
    }

    // --- Helper Methods ---

    private String getCellValue(Cell cell) {
        if (cell == null)
            return "";
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue().trim();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell))
                    return cell.getDateCellValue().toString();
                else
                    return String.valueOf((long) cell.getNumericCellValue());
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            default:
                return "";
        }
    }

    private boolean containsAny(String str, String... keywords) {
        if (str == null)
            return false;
        String lower = str.toLowerCase();
        for (String k : keywords) {
            if (lower.contains(k.toLowerCase()))
                return true;
        }
        return false;
    }

    private boolean startsWithAny(String str, String... prefixes) {
        if (str == null)
            return false;
        for (String p : prefixes) {
            if (str.startsWith(p))
                return true;
        }
        return false;
    }

    private String extractPath(String output) {
        if (output == null)
            return "";
        Pattern p = Pattern.compile("Path\\s*:\\s*([^\\s\\n\\r]+)", Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(output);
        return m.find() ? m.group(1) : "";
    }

    private String extractVersion(String output) {
        if (output == null)
            return "";
        Pattern p = Pattern.compile("(Reported Version|Installed version)\\s*:\\s*([^\\s\\n\\r]+)",
                Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(output);
        return m.find() ? m.group(2) : "";
    }

    private String extractFix(String output) {
        if (output == null)
            return "";
        Pattern p = Pattern.compile("(Fixed version|Should be)[^0-9]*([0-9]+(?:\\.[0-9a-z]+)+)",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher m = p.matcher(output);
        if (m.find()) {
            return m.group(2);
        }
        return "";
    }

    private String deriveSoftware(String path) {
        if (path == null)
            return "Unknown";
        String lower = path.toLowerCase();
        if (lower.contains("apache"))
            return "Apache";
        if (lower.contains("java") || lower.contains("jdk") || lower.contains("jre"))
            return "Java";
        if (lower.contains("tomcat"))
            return "Tomcat";
        if (lower.contains("jboss") || lower.contains("wildfly"))
            return "JBoss";
        if (lower.contains("weblogic"))
            return "WebLogic";
        if (lower.contains("nginx"))
            return "Nginx";
        if (lower.contains("openssl"))
            return "OpenSSL";
        return "Middleware";
    }

    private String findNearestVersion(List<String> available, String target) {
        if (available == null || available.isEmpty())
            return "";
        if (target == null || target.isEmpty())
            return available.get(0);

        // Exact match
        if (available.contains(target))
            return target;

        // Try to find same major version
        String major = target.split("\\.")[0];
        for (String v : available) {
            String vMajor = v.split("\\.")[0];
            if (vMajor.equals(major))
                return v;
        }

        // Return latest available as fallback
        return available.get(0);
    }
}
