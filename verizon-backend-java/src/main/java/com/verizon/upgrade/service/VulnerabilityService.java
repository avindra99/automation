package com.verizon.upgrade.service;

import com.verizon.upgrade.dto.VulnerabilityResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
@Slf4j
public class VulnerabilityService {

    public List<VulnerabilityResponse> parseVulnerabilityExcel(MultipartFile file) throws Exception {
        // Use a Set to automatically remove duplicate rows
        Set<VulnerabilityResponse> uniqueResults = new LinkedHashSet<>();

        try (Workbook workbook = WorkbookFactory.create(file.getInputStream())) {
            Sheet sheet = workbook.getSheetAt(0);

            // --- STEP 1: Attempt to find headers dynamically ---
            int ipIdx = -1, hostIdx = -1, familyIdx = -1, vulIdx = -1, outputIdx = -1;
            boolean headersFound = false;
            int headerRowNum = -1;

            log.info("Starting Header Search (Full File)...");
            Iterator<Row> searchIterator = sheet.iterator();
            while (searchIterator.hasNext()) {
                Row row = searchIterator.next();

                // LIMIT REMOVED: We now scan every row until headers are found or EOF

                for (Cell cell : row) {
                    String h = getCellValue(cell).toLowerCase().trim();
                    if (ipIdx == -1 && (h.contains("ip address") || h.equals("ip"))) ipIdx = cell.getColumnIndex();
                    else if (hostIdx == -1 && (h.contains("hostname") || h.contains("dns name") || h.contains("system name") || h.contains("asset name"))) hostIdx = cell.getColumnIndex();
                    else if (familyIdx == -1 && (h.contains("family") || h.contains("plugin family"))) familyIdx = cell.getColumnIndex();
                    else if (vulIdx == -1 && (h.contains("vul name") || h.contains("plugin name") || h.equals("name"))) vulIdx = cell.getColumnIndex();
                    else if (outputIdx == -1 && (h.contains("plugin output") || h.contains("output"))) outputIdx = cell.getColumnIndex();
                }

                // If we found the critical columns, lock them in
                if (ipIdx != -1 && hostIdx != -1) {
                    headersFound = true;
                    headerRowNum = row.getRowNum();
                    // Set defaults for others if specific headers weren't matched
                    if (familyIdx == -1) familyIdx = 36;
                    if (vulIdx == -1) vulIdx = 35;
                    if (outputIdx == -1) outputIdx = 46;
                    log.info("Headers FOUND on Row {}: IP={} Host={} Family={} Vul={} Output={}", headerRowNum, ipIdx, hostIdx, familyIdx, vulIdx, outputIdx);
                    break;
                }
                // Reset for next row
                ipIdx = -1; hostIdx = -1; familyIdx = -1; vulIdx = -1; outputIdx = -1;
            }

            // --- STEP 2: Fallback if headers missing ---
            if (!headersFound) {
                log.warn("Headers NOT found by name after scanning full file. Falling back to OBSERVED LOG INDICES.");
                // CORRECTED INDICES BASED ON YOUR LOGS
                ipIdx = 0;
                hostIdx = 1;
                vulIdx = 35;
                familyIdx = 36;
                outputIdx = 46;
            }

            // --- STEP 3: Process Data ---
            Iterator<Row> dataIterator = sheet.iterator();
            while (dataIterator.hasNext()) {
                Row row = dataIterator.next();

                // Skip header row and empty rows
                if (row.getRowNum() == headerRowNum || row == null || row.getLastCellNum() <= 0) continue;

                // Skip if this looks like a header repetition
                String checkIp = getCellValue(row.getCell(ipIdx));
                if (checkIp.toLowerCase().contains("ip address") || checkIp.toLowerCase().equals("ip")) continue;

                Cell familyCell = row.getCell(familyIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                Cell outputCell = row.getCell(outputIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);

                String family = getCellValue(familyCell);
                String pluginOutput = getCellValue(outputCell);

                // 1. General Exclusion Filter
                if (containsAny(family, "Local security checks", "Kernal.", "General", "Oracle Linux Local Security Checks")) {
                    continue;
                }

                String path = extractPath(pluginOutput);
                if (path.isEmpty()) continue; // Skip if no path found

                // 2. STRICT PATH FILTERING: Only /apps/opt/application/mw or /apps/opt/mw
                boolean isTargetMiddleware = startsWithAny(path, "/apps/opt/application/mw", "/apps/opt/mw");

                if (isTargetMiddleware) {
                    VulnerabilityResponse responseRow = VulnerabilityResponse.builder()
                            .hostname(getCellValue(row.getCell(hostIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .ipAddress(getCellValue(row.getCell(ipIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .vulnerabilities(getCellValue(row.getCell(vulIdx, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK)))
                            .directory(path)
                            .software(deriveSoftware(path))
                            .currentVersion(extractVersion(pluginOutput))
                            .targetVersion(extractFix(pluginOutput))
                            .status("pending")
                            .action("patch now")
                            .build();

                    // Add to Set (automatically handles duplicates)
                    uniqueResults.add(responseRow);
                }
            }
        }

        log.info("Finished parsing. Found {} unique vulnerabilities.", uniqueResults.size());
        return new ArrayList<>(uniqueResults);
    }

    // --- Helper Methods ---

    private String getCellValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING: return cell.getStringCellValue().trim();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) return cell.getDateCellValue().toString();
                else return String.valueOf((long)cell.getNumericCellValue());
            case BOOLEAN: return String.valueOf(cell.getBooleanCellValue());
            case FORMULA: return cell.getCellFormula();
            default: return "";
        }
    }

    private boolean containsAny(String str, String... keywords) {
        if (str == null) return false;
        String lower = str.toLowerCase();
        for (String k : keywords) {
            if (lower.contains(k.toLowerCase())) return true;
        }
        return false;
    }

    private boolean startsWithAny(String str, String... prefixes) {
        if (str == null) return false;
        for (String p : prefixes) {
            if (str.startsWith(p)) return true;
        }
        return false;
    }

    private String extractPath(String output) {
        if (output == null) return "";
        Pattern p = Pattern.compile("Path\\s*:\\s*([^\\s\\n\\r]+)", Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(output);
        return m.find() ? m.group(1) : "";
    }

    private String extractVersion(String output) {
        if (output == null) return "";
        Pattern p = Pattern.compile("(Reported Version|Installed version)\\s*:\\s*([^\\s\\n\\r]+)", Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(output);
        return m.find() ? m.group(2) : "";
    }

    private String extractFix(String output) {
        if (output == null) return "";
        Pattern p = Pattern.compile("(Fixed version|Should be)[^0-9]*([0-9]+(?:\\.[0-9a-z]+)+)",
                Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher m = p.matcher(output);
        if (m.find()) {
            return m.group(2);
        }
        return "";
    }

    private String deriveSoftware(String path) {
        if (path == null) return "Unknown";
        String lower = path.toLowerCase();
        if (lower.contains("apache")) return "Apache";
        if (lower.contains("java") || lower.contains("jdk") || lower.contains("jre")) return "Java";
        if (lower.contains("tomcat")) return "Tomcat";
        if (lower.contains("jboss") || lower.contains("wildfly")) return "JBoss";
        if (lower.contains("weblogic")) return "WebLogic";
        if (lower.contains("nginx")) return "Nginx";
        if (lower.contains("openssl")) return "OpenSSL";
        return "Middleware";
    }
}
